
import webbrowser
'''Функции высшего порядка
 Функция высшего порядка — в программировании это функция, принимающая в качестве аргументов другие функции
 или возвращающая другую функцию в качестве результата.

 Основная идея состоит в том, что функции имеют тот же статус, что и другие объекты данных.

 Мы можем передавать функции как параметры:
 def my_func(inside_func):
     inside_func()  # Вызов функции принятой в качестве аргумента

 def a():
     def b(): 
         pass
     return b'''

"""Для лучшего понимания функций высшего порядка можно представить себе конвейер, который собирает других роботов. 
То есть некая техника собирает другую технику.

Сделаем функцию, которая будет выполнять принимаемую функцию дважды:"""

def twice_func(inside_func):
   """Функция, выполняющая дважды функцию, принятую в качестве аргумента"""
   inside_func()
   inside_func()

def hello():
   print("Hello")
  
test = twice_func(hello)
# Hello
# Hello
# Видим, что после передачи функции hello в качестве аргумента для функции twice_func, она выполнялась в ней дважды. 
# Теперь перейдём к теме замыкания функций и разберём, что это такое.

# Замыкание в программировании — это функция, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции в окружающем коде и не являющиеся её аргументами.
# Вспомните нелокальную (nonlocal) область видимости, на этом принципе работает замыкание функций.

# Сделаем функцию, которая будет возвращать функцию, всегда прибавляющую одно и тоже число x:

def make_adder(x):
   def adder(n):
       return x + n # захват переменной "x" из nonlocal области
   return adder  # возвращение функции в качестве результата
# То есть мы сделали конвейер, который будет нам прибавлять фиксированное число x к любому числу n (см. функции высших порядков). Тогда сделаем функцию, которая будет прибавлять число 5 к любому числу.

# функция, которая будет к любому числу прибавлять пятёрку
add_5 = make_adder(5)
print(add_5(10))  # 15
print(add_5(100))  # 105
# Определив функции высших порядков и замыкание функций, давайте перейдём к теме декораторов, которая основывается на них.

# Декораторы предназначены для подключения любого дополнительного поведения к основной функции, называемой декорируемой функцией,
#  которое может выполняться до, после или даже вместо основной функции. При этом исходный код декорируемой функции никак не затрагивается.

# В качестве дополнительного поведения может выступать подсчёт времени выполнения функции,
#  проверка дополнительных условий, разрешающих выполнение указанной функции.
def my_decarator(a_function_to_decorate):
   def wrapper():
      result = a_function_to_decorate()
      return result
   return wrapper
# На рисунке выше представлен простейший декоратор, который не выполняет никаких дополнительных действий.

# Желтым выделена декорируемая функция, которая принимается декоратором my_decorator в качестве аргумента благодаря функциям высшего порядка. 
# Далее декорируемая функция через замыкание передаётся в декорированную функцию wrapper.
# И уже декорированную функцию, которая как раз и может добавлять дополнительное поведение к основной, возвращает сам декоратор (57-61).

# Давайте посмотрим на примере, как добавить дополнительное поведение к основной функции.

def my_decorator(a_function_to_decorate):
    # Здесь мы определяем новую функцию - «обёртку». Она нам нужна, чтобы выполнять
    # каждый раз при вызове оригинальной функции, а не только один раз
    def wrapper():
        # здесь поместим код, который будет выполняться до вызова, потом вызов
        # оригинальной функции, потом код после вызова
        print("Я буду выполнен до основного вызова!")
        
        result = a_function_to_decorate()  # не забываем вернуть значение исходной функции
        
        print("Я буду выполнен после основного вызова!")
        return result
    return wrapper
# Наш декоратор будет печатать строку «Я буду выполнен до основного вызова!» перед основным вызовом, 
# а строка «Я буду выполнен после основного вызова!» соответственно после основного вызова. Если необходимо, 
# то не забываем вернуть результат исходной функции.
def my_function():
   print("Я - оборачиваемая функция!")
   return 0

print(my_function())
# Я оборачиваемая функция!
# 0

decorated_function = my_decorator(my_function)  # декорирование функции
print(decorated_function())
# Я буду выполнен до основного вызова!
# Я оборачиваемая функция!
# Я буду выполнен после основного вызова!
# 0


def validator(func):
   def wrapper(url):
      if "." in url:
         func(url)
      else:
         print("Неверный URL")
         
   return wrapper

@validator
def open_url(url):
   webbrowser.open(url)

open_url("https://www.youtube.com/watch?v=W8ZM9vnGmfs")


