# # В Python существует 3 области видимости:

# локальная,
# глобальная,
# нелокальная (добавлена в Python 3)

def local():
   x = 5  # локальная переменная
   print(x)

x = 10
local()
print(x)

# 5
# 10
def local():
   print(x)  # так как x нет в локальной области видимости, мы берём её из глобальной области

x = 105
local()
print(x)

# 10
# 10
# Если запустить данный код, то мы увидим, что распечаталось два раза значение 10. Это происходит, потому что, не найдя переменной в локальной области,
# функция обращается к глобальной области видимости, которая находится на уровне модуля, и берёт значение оттуда.
# И здесь не нарушается так называемое «правило бункера». Из бункера мы можем увидеть, что происходит во внешнем мире, но вот наоборот это не работает.

x = 33
def function():
    print(x)
    return x

print(function())

x = 45
def func():
   print(x)
   x = 5
   x += 5
   return x

# print(func())

# Ошибка возникает, потому что Python замечает, что вы пытаетесь распечатать значение локальной (!) переменной х в функции func до её объявления,
# что и приводит к ошибке, так как х ещё не определён.(область видимости переменной (где она может использоваться) всегда определяется местом, где ей было присвоено значение.)

# Как обойти это ограничение? Нужно использовать оператор global, который объявляет переменную доступной для блока кода, следующим за оператором. 
# Давайте попробуем использовать глобальную область видимости для исправления нашей ошибки из предыдущего примера:

x = 1020301

def func():
   global x # объявляем, что переменная является глобальной
   print(x)
   x = 5
   x += 6
   return x

func()
print(x)


# Нелокальная область видимости
# Появилось это понятие в Python 3 вместе с ключевым словом nonlocal. Логика его написания примерно такая же, как и у global. 
# Но у nonlocal есть особенность. Nonlocal используется чаще всего во вложенных функциях, когда мы хотим дать интерпретатору понять, 
# что для вложенной функции определённая переменная не является локальной, но она и не является глобальной в общем смысле. 
# Предположим, мы хотим сделать функцию, которая будет возвращать нам функции (да, в Python такое возможно).

# Рассмотрим такой пример:

def get_my_func():
   def hello_world():
       print("Hello")
   return hello_world

hello_world_func = get_my_func()  # получить функцию в качестве результата

print(type(hello_world_func))  # <class 'function'>
hello_world_func()  # Hello

def get_mul_func(m):
   nonlocal_m = m
   def local_mul(n):
       return n * nonlocal_m
  
   return local_mul

two_mul = get_mul_func(2)  # возвращаем функцию, которая будет умножать числа на 2
two_mul(5)  # 5 * 2

def my_func(a,b):
   result = a+b
   return result

c = my_func(5, 10)
print(c)

def my_print():
   print(c)

my_print()

PI = 3.14#глобальная переменная
#print("Число выведенное из 1 Глобальной области видимости:", PI)
def area_circle(r):
   global PI
   print("Число из локальной переменной до изменения:",PI)

   PI=3.141592#изменение глобальной переменной
   print("Число из локальной переменной после изменения:", PI)
   return(PI*(r**2))
print("Число выведенное из Глобальной области видимости до вызова функции:", PI)
print(area_circle(3))
print("Число выведенное из Глобальной области видимости после вызова функции:", PI)
#НЕ ИЗМЕНЯТЬ ЗНАЧЕНИЕ ФУНКЦИИ ВНУТРИ ФУНКЦИИ

# Запакованные переменные, или что такое *args и **kwargs
# Для начала давайте разберёмся с позиционными (positional) и именованными (keyword) аргументами. 
# Из названий можно предположить, что одни аргументы зависят от позиции, а вторые — от имени, всё логично.
def func(a, b, c):
   print('a =', a)
   print('b =', b)
   print('c =', c)

func(1, 2, 3)
# a = 1
# b = 2
# c = 3

func(3, 2, 1)
# a = 3
# b = 2
# c = 1

# Но никто не запрещает нам обращаться к переменным прямо по имени:

func(a=1, b=2, c=3)
# a = 1
# b = 2
# c = 3

func(c=3, b=2, a=1)
# a = 1
# b = 2
# c = 3
# Важная особенность: все именованные аргументы должны идти строго после позиционных как при объявлении функций, так и при их вызове.

# Правильно
# func(a, b, c=3)

# Неправильно
# func(a=1, b, c)
a = [1, 2, 3]
b = [a, 4, 5, 6]
print(b)
# [[1, 2, 3], 4, 5, 6]

a = [1, 2, 3]
b = [*a, 4, 5, 6]
print(b)
# [1, 2, 3, 4, 5, 6]

# Чтобы правильно обрабатывать *args и **kwargs нужно представлять, чем они являются. А собственно args — это кортеж, а kwargs  — это словарь.

def my_func(*args, **kwargs):
   print(type(args))
   print(type(kwargs))

my_func()
# <class 'tuple'>
# <class 'dict'>


def adder(*nums):
   sum_ = 0
   for n in nums:
       sum_ += n
  
   return sum_

print(adder())  # 0
print(adder(1))  # 1
print(adder(1, 2))  # 3
print(adder(1, 2, 3))  # 6

# Написать функцию, которая будет перемножать любое количество переданных ей аргументов.

def apper(*nums):
   sum_ = 1
   for n in nums:
       sum_ *= n
  
   return sum_

print(apper())  # 0
print(apper(1))  # 1
print(apper(1, 2))  # 3
print(apper(1, 2, 3, 4))#24 

def incorrect_func(name_arg=[]):
   # name_arg является локальной переменной
   print("Аргумент до изменения", name_arg)
   name_arg.append(1)
   print("Аргумент после изменения", name_arg)

# вызовем два раза одну и ту же функцию
incorrect_func()
print('-----')
incorrect_func()
print('-----')
incorrect_func()


# Аргумент до изменения []
# Аргумент после изменения [1]
# -----
# Аргумент до изменения [1]
# Аргумент после изменения [1, 1]

# установим аргумент name_arg пустым, а внутри функции будем проверять его
def correct_func(name_arg=None):
   if name_arg is None:
       name_arg = []
   print("Аргумент до изменения", name_arg)
   name_arg.append(1)
   print("Аргумент после изменения", name_arg)

# вызовем два раза одну и ту же функцию
correct_func()
print('-----')
correct_func()
print('-----')
correct_func([123])
print('-----')
correct_func(name_arg=[123])

# Аргумент до изменения []
# Аргумент после изменения [1]
# -----
# Аргумент до изменения []
# Аргумент после изменения [1]
# -----
# Аргумент до изменения [123]
# Аргумент после изменения [123, 1]
# -----
# Аргумент до изменения [123]
# Аргумент после изменения [123, 1]


def necorect_func(name_args=[]):
   
   
   print("Аргумент до изменения", name_args)
   name_args.append(1)
   print("Аргумент после измененеия", name_args)

necorect_func()
print("---------")
necorect_func()