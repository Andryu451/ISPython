# И отдельное внимание уделяли проверке тождественности объекта с загадочным NoneType. Это тип, у которого может быть один и только один объект — None. По своему смыслу это буквально «ничто», и потому не имеет никакого поведения. Зачем тогда использовать его? Во-первых, чтобы объявить переменную, но не определять ей какое-то значение.

some_var = (2,)
# Во-вторых, такие объекты удобны при использовании в функциях в качестве начальных значений аргументов и/или возвращаемого значения. Применений множество, но важно помнить, что если мы хотим проверить переменную, является ли она «ничем», то нужно обязательно использовать is, а не ==, иначе можно получить неожиданный результат.

if some_var is None:
    print("NoneType")
else:
    print(type(some_var))

# Ранее мы использовали логические операторы только в условных выражениях, что вполне закономерно. Однако их можно использовать в неожиданных местах.

a = '' # пустая строка
b = a or 1
# Что сейчас произошло? Мы объявили переменную как None, а потом использовали логический оператор or (логическое ИЛИ) в выражении,
#  которое присвоили другой переменной. Может выглядеть странно, но это работает!

# Дело в том, что логические операторы возвращают не обязательно булевы значения (True или False), а значение одного из операндов.
# Это происходит согласно следующим правилам:

# and: если все операнды являются истинными (ненулевые или непустые), то возвращается последнее истинное значение.
print( 1 and "hello" and [False])
# [False]
# Несмотря на то, что последний операнд похож на False, он является непустым списком, а значит он истинный.

# and: если один из операндов является ложным, то возвращается первый такой операнд.
print(42 and 0 and '' and False)
# 0
# Первый операнд является ненулевым числом — значит истинный, а все остальные — ноль, пустая строка, булево значение False — ложные. 
# И согласно правилу возвращается первый ложный операнд (слева направо).

# or: если один из операндов является истинным, то возвращается первый такой операнд, а остальные игнорируются.
print([] or 3.14 or False)
# 3.14
# Первый операнд (пустой список) является ложным, следующий (ненулевое число) — истинным, а значит, возвращается именно он, 
# а все остальные игнорируются (не вычисляются).

# or: если все операнды являются ложными, то возвращается последний.
print(0 or '' or False)
# False
# Поиск истинного операнда идёт также слева направо, но раз ни один такой не нашёлся, возвращается последнее значение, даже если оно ложное.

# Это можно было бы сделать в виде условного оператора:

if a is None:
    b = 1
else:
    b = a
# Выглядит многострочно. Можно использовать тернарный оператор (или его ещё называют инлайновым условным оператором):

b = a if a is not None else 1

a = "foo"
b = "bar"

print(1 and a or b)

# пусть a и b - переменные, которые мы хотим проверить
if a and b : # проверка истинности обеих переменных
    print("Обе переменные истинные")
    print(a,b)

# пусть a и b - переменные, которые мы хотим проверить
if a and b:
    print("Обе переменные истинные")
    print(a,b)
elif a or b:
    print("Одна из переменных истинная")
    print(a or b) # печать значения одной переменной, которая является истинной
# пусть a и b - переменные, которые мы хотим проверить
if a or b:
    print("Обе переменные истинные")
    print(a,b)
elif a or b:
    print("Одна из переменных истинная")
    print( a or b ) # печать одной переменной, которая является истинной
else:
    print("Обе переменные ложные")


# Представим, что на вход нашей программы подаётся число. А мы хотим проверить, является ли оно целым, находится ли в определённом промежутке 
# (например, от 100 до 999 включительно), да ещё и делится ли на 2 и 3 одновременно. Очень много условий. И такое случается в реальных проектах.

# Решение в лоб — использовать вложенные условные операторы. Один if внутри другого if и т.д. Наверняка есть способ сделать это быстрее и 
# эффективнее, но для начала попробуем написать решение в таком варианте, чтобы было с чем сравнить:

if type(a) == int:
    if 100 <= a <= 999:
        if a % 2 == 0:# Если а делится на 2 без остатка
            if a % 3 == 0:# Если а делится на 3 без остатка
                print("Число удовлетворяет условиям")

a = int(input())
if 100 <= a <= 999 and type(a) == int and a % 2 == 0 and a % 3 == 0:
    print("Число удовлетворяет всем условиям")
else:
    print("Число не удовлетворяет всем условиям")

if type(a) == int and 100 <= a <= 999 and a % 2 == 0 and a % 3 == 0:
    print("Число удовлетворяет условиям")

# В Python есть функция all([ ]), которая возвращает True, если все условия, 
# переданные в аргумент функции в виде списка, являются истинными.

if all([type(a) == int,
        100 <= a <= 999,
        a % 2 == 0,
        a % 3 == 0]):
    print("Число удовлетворяет условиям")

#Такой подход является достаточно лаконичным и более эффективным, он более «питоновский».

#Функция all([ ]) возвращает True, если все элементы списка являются истинными. А что, если нужно, чтобы был хотя бы один истинный? 
# Тогда на помощь приходит функция any([ ]). Её работа аналогична рассмотренному выше примеру.

# Напишите программу, которая на вход принимает последовательность целых чисел и возвращает True при вводе любых чисел и False,
# если ввести последовательность из нулей.

L = list(map(int, input().split()))

print(any(L))

#and = функция all
#or = функция any

# Задание 6.3.12
# Задание на самопроверку.
# Напишите программу, которая на вход принимает последовательность целых чисел и возвращает True, если все числа равны нулю, и False, 
# если найдётся хотя бы одно ненулевое число. Разрешается использование только логических операторов и функций all([ ]) и any([ ])


L = list(map(int, input().split()))

print(not any(L))

# Генераторы списков — это специальный синтаксис, определяющий правила создания и заполнения списков.
# В общем виде эта конструкция записывается следующим образом:
# L = [ a for a in some_iter_obj if cond ] 
# Такая запись аналогична следующей:
# L = []
# for a in some_iter_obj:
#     if cond:
#         L.append(a) 

# Напишем генератор списков, в котором будут храниться квадраты первых 10 натуральных чисел.

squares = [i**2 for i in range(1,11)]
# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

squares = [i**2 for i in range(1,11) if i % 2 == 1]
# [1, 9, 25, 49, 81]

list_tuples = [(i, i**2) for i in range(1,11)]
#[(1, 1),
# (2, 4),
# (3, 9),
# (4, 16),
# (5, 25),
# (6, 36),
# (7, 49),
# (8, 64),
# (9, 81),
# (10, 100)]

M = [[i+j for j in range(5)] for i in range(5)]
#[[0, 1, 2, 3, 4],
# [1, 2, 3, 4, 5],
# [2, 3, 4, 5, 6],
# [3, 4, 5, 6, 7],
# [4, 5, 6, 7, 8]]

# Задание 6.3.13
# При помощи генератора списков создайте таблицу умножения чисел от 1 до 10
T = [[i*j for j in range(1,11)] for i in range(1,11)]
print(T)

# Интересный эффект образуется в сочетании использования генераторов списков и функции input(). На каждой итерации 
# цикла консоль будет запрашивать данные для ввода и сохранять их в качестве элемента списка.

# L = [input() for i in range(5)]

# Приведённый выше пример 5 раз запросит у пользователя данные для входа и запишет их в список. Здесь же можно 
# использовать сразу преобразование в необходимый тип, если он заранее известен.

# L = [int(input()) for i in range(5)]

# Задание 6.3.14
# Модифицируйте последний пример таким образом, чтобы в список сохранялось True, если элемент чётный,
# и False, если элемент нечётный.

P = [int(input()) % 2 == 0 for i in range(5)]

print(P)

O = [int(input()) % 2 == 0 for i in range(5)]
print(any(O))

# Подумайте, как нужно записать логическое выражение, используя all([ ]) и any([ ]) над списком чётности, если его 
# результат будет истинным тогда и только тогда, когда в списке есть хотя бы один чётный и хотя бы один нечётный элемент.
# any(L) and not all(L)

# Допустим у нас есть два списка одинакового размера:

L = [i for i in range(10)]
# 0 1 2 3 4 5 6 7 8 9
M = [i for i in range(10,0,-1)]
# 10 9 8 7 6 5 4 3 2 1

# И нам необходимо создать новый список, который будет состоять из произведений соответствующих элементов друг на друга.

# он должен выглядеть так
# 0 9 16 21 24 25 24 21 16 9

# Мы знаем, что элементов в списке 10, поэтому можем пробежаться в цикле по индексам от 0 до 10:

N = [ ]

for i in range(10):
    N.append(L[i] * M[i])

# Такой код является корректным, но не «питоновским». Мы знаем, что циклом for можно итерировать сразу списки.

# Но хотелось бы сделать так же, только сразу по двум спискам. В Python существует функция zip(), которая 
# позволяет объединить два списка в новый список кортежей, каждый из которых будет содержать по одному элементу из каждого списка.

# for a in zip(L,M):
    # print(a)
#(0, 10)
#(1, 9)
#(2, 8)
#(3, 7)
#(4, 6)
#(5, 5)
#(6, 4)
#(7, 3)
#(8, 2)
#(9, 1)

for a, b in zip(L,M):
    print('a =', a, 'b =', b)
#a = 0 b = 10
#a = 1 b = 9
#a = 2 b = 8
#a = 3 b = 7
#a = 4 b = 6
#a = 5 b = 5
#a = 6 b = 4
#a = 7 b = 3
#a = 8 b = 2
#a = 9 b = 1

# Используя функцию zip() внутри генераторов списков, вычислите поэлементные произведения списков L и M.

N = [a*b for a,b in zip(L,M)]
print(N)

# Реализуйте программу, которая сжимает последовательность символов. На вход подаётся последовательность вида:

# aaabbccccdaa

# Необходимо вывести строку, состоящую из символов и количества повторений этого символа. Вывод должен выглядеть как:

# a3b2c4d1a2

text = input() # получаем строку

last = text[0] # сохраняем первый символ
count = 0 # заводим счетчик
result = '' # и результирующую строку

for c in text:
    if c == last: # если символ совпадает с сохраненным, 
        count += 1 # то увеличиваем счетчик
    else:
        result += last + str(count) # иначе - записываем в результат
        last = c # и обновляем сохраненный символ с его счетчиком
        count = 1
        
result += last + str(count) # и добавляем в результат последний символ
print(result)
