# Для начала напишем простую функцию, которая будет решать обычное линейное уравнение:

# a*x = b
# x = b/a

# В первую очередь мы должны понимать, от чего зависит работа функции, что послужит аргументами функции. А также должны понять,
#  будет ли у функции возвращаемое значение. Наша функция зависит от двух чисел-параметров и должна вернуть одно значение.

# def linear_solve(a, b):
    # return b/a

# print(linear_solve(0,1))

# Оказывается, наша функция может решать не все уравнения. Хотя оно казалось простым.

# Модифицируем её код, чтобы она могла учитывать такое поведение.

def linear_solve(a, b):
    if a: # помним, что 0 интерпретируется как False, иначе True
        return b/a
    else:
        return "Нет корней"

# Однако и здесь кроется неожиданность. Ведь, если и a=0, и b=0, уравнение имеет бесконечное количество корней 
# (любое число при умножении на ноль даст ноль). А наша программа вернёт «Нет корней». Так быть не должно. Модифицируем нашу программу еще раз.

def linear_solve(a, b):
    if a: 
        return b/a
    elif not a and not b: # снова используем числа в логических выражениях
        return "Бесконечное количество корней"
    else:
        return "Нет корней"
# Вот теперь всё работает отлично!


# сложним задачу и реализуем функцию, решающую квадратные уравнения. Вспомним сначала матчасть:

# a*x**2 + b*x + c = 0 - общий вид уравнения
# D = b**2 - 4*a*c - дискриминант
# Если D<0, то уравнение не имеет вещественных корней
# Если D=0, то уравнение имеет один корень - x = -b/(2*a)
# Если D>0, то уравнение имеет два корня
# x1 = (-b - D**0.5)/(2*a)
# x2 = (-b + D**0.5)/(2*a)
#
# P.S. D**0.5 - равносильно извлечению квадратного корня

# Пойдём поэтапно. Сначала напишем функцию, вычисляющую дискриминант уравнения.

def D(a,b,c):
    return b**2 - 4*a*c

def quadratic_solve(a,b,c):
    if D(a,b,c) < 0:
        return "Нет вещественных корней"
    
def quadratic_solve(a,b,c):
    if D(a,b,c) < 0:
        return "Нет вещественных корней"
    elif D(a,b,c) == 0:
        return -b/(2*a)
    
# И последним этапом нам нужно вернуть сразу два значения. Конечный вид функции будет выглядеть так:

def quadratic_solve(a,b,c):
    if D(a,b,c) < 0:
        return "Нет вещественных корней"
    elif D(a,b,c) == 0:
        return -b/(2*a)
    else:
        return (-b-D(a,b,c)**0.5)/(2*a), (-b+D(a,b,c)**0.5)/(2*a)
print(quadratic_solve(2,3,14))
# И, наконец, потренируемся с одним удобным способом использования функций. Представим, что параметры уравнения хранятся в виде списка.
#  Такое может быть, если аргументы были получены из консоли.

# разбили строку из input и преобразовали к float
# L = list(map(float, input().split())) 
# [1, 0, -1] - например

# Напишите рекурсивную функцию, находящую минимальный элемент списка без использования циклов и встроенной функции min().
L = [1,2,3,4,5,6,7,8,9]
def min_list(L):
    if len(L) == 1:
        return L[0]
    return L[0] if L[0] < min_list(L[1:]) else min_list(L[:-1])

print(min_list(L))

#  Сейчас попробуем реализовать функцию equal(N, S), проверяющую, совпадает ли сумма цифр числа N с числом S.
#  При написании программы следует обратить внимание на то, что если S стала отрицательной, то необходимо сразу вернуть False.

def equal(N, S):
    if S < 0:
        return False
    if N < 10:
        return N == S
    else:
        return equal(N // 10, S - N % 10) 

# Теперь попробуем написать генератор для приближённого вычисления числа e = 2.718.
# Для нахождения числа, удовлетворяющего необходимой точности, будем использовать следующий цикл:

# Теперь попробуем написать генератор для приближённого вычисления числа e = 2.718. Для нахождения числа, удовлетворяющего необходимой точности,
#  будем использовать следующий цикл:

# last = 0
# for a in e(): # e() - генератор
#     if (a - last) < 0.00000001: # ограничение на точность
#         print(a)
#         break # после достижения которого завершаем цикл
#     else:
#         last = a # иначе - присваиваем новое значение 

# Для вычисления числа e с определённой точностью можно использовать формулу:

# e_n = (1 + 1/n)**n

# В этой формуле число n — натуральное (1, 2, 3 и т. д.).

def e():
    n = 1
    while True:
        yield (1+1/n)**n
        n += 1

iter_obj = iter("Hello!")

print(next(iter_obj)) 

# Пусть у нас есть функция, которая должна извлекать из базы данных какую-то информацию. На начальном этапе разработки мы не заботились о том,
# что это можно делать только при условии, что пользователь программы авторизовался, но сейчас время пришло. Попробуем написать декоратор,
# который позволяет вызвать функцию, только если она вызывается авторизованным пользователем.

yesno = input("""Введите Y, если хотите авторизоваться, или N, если хотите продолжить работу как анонимный пользователь: """)

auth = yesno == "Y"

def is_auth(func):
    def wrapper():
        if auth:
            print("Пользователь авторизован")
            func()
        else:
            print("Пользователь неавторизован. Функция выполнена не будет")
    return wrapper

@is_auth
def from_db():
    print("some data from database")

from_db()

# Самая главная фишка декораторов в том, что такую обёртку можно использовать для многих функций. 
# Если в нашу программу хотим добавить ещё одну функцию, для которой мы бы хотели сначала проверить авторизацию пользователя,
# достаточно всего лишь указать для неё декоратор.

@is_auth
def change_profile():
    print("Profile has been changed")

# Реализуйте функцию-декоратор, которая проверяет доступ к функции по username пользователя. 
# Все username пользователей хранятся в глобальной области видимости в списке USERS. 
# При согласии пользователя на авторизацию ему предлагается ввести username, который также хранится в глобальной области видимости. 
# Функция должна использовать два декоратора: один для проверки авторизации вообще (реализован выше), второй — для проверки доступа.



USERS = ['admin', 'guest', 'director', 'root', 'superstar']
def has_access(func):
    def wrapper():
        if username in USERS:
            print("Авторизован как", username)
            func()
        else:
            print("Доступ пользователю", username, "запрещён")
    return wrapper
yesno = input("""Введите Y, если хотите авторизоваться или N, 
             если хотите продолжить работу как анонимный пользователь: """)

auth = yesno == "Y"

if auth:
    username = input("Введите ваш username:")

@is_auth
@has_access
def from_db():
    print("some data from database")

from_db()